/**
 * @file      hound.h
 * @brief     Hound public library header.
 * @author    Martin Kelly <mkelly@xevo.com>
 * @copyright Copyright (C) 2019 Xevo Inc. All Rights Reserved.
 */

#ifndef HOUND_H_
#define HOUND_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <time.h>

/* Errors. */

/** hound error codes are negative while errno codes are positive. */
typedef enum {
    HOUND_OK = 0,
    HOUND_NULL_VAL = -1,
    HOUND_OOM = -2,
    HOUND_DRIVER_ALREADY_REGISTERED = -3,
    HOUND_DRIVER_NOT_REGISTERED = -4,
    HOUND_DRIVER_IN_USE = -5,
    HOUND_MISSING_DEVICE_IDS = -6,
    HOUND_CONFLICTING_DRIVERS = -7,
    HOUND_NO_DATA_REQUESTED = -8,
    HOUND_DATA_ID_DOES_NOT_EXIST = -9,
    HOUND_CTX_ACTIVE = -10,
    HOUND_CTX_NOT_ACTIVE = -11,
    HOUND_EMPTY_QUEUE = -12,
    HOUND_MISSING_CALLBACK = -13,
    HOUND_PERIOD_UNSUPPORTED = -14,
    HOUND_IO_ERROR = -15,
    HOUND_QUEUE_TOO_SMALL = -16,
    HOUND_INVALID_STRING = -17,
    HOUND_DRIVER_UNSUPPORTED = -18,
    HOUND_DRIVER_FAIL = -19,
    HOUND_INVALID_VAL = -20,
    HOUND_INTR = -21,
    HOUND_DEV_DOES_NOT_EXIST = -22,
    HOUND_TOO_MUCH_DATA_REQUESTED = -23,
    HOUND_DUPLICATE_DATA_REQUESTED = -24,
    HOUND_DRIVER_ALREADY_PRESENT = -25,
    HOUND_CTX_STOPPED = -26,
    HOUND_NO_DESCS_ENABLED = -27
} hound_err;

/**
 * Returns a human-readable error string. The string must not be modified or
 * freed, but it may be modified by subsequent calls to hound_strerror or the
 * libc strerror class of functions.
 *
 * @param[in] err an error code
 *
 * @return a human-readable error string
 * */
const char *hound_strerror(hound_err err);

/**
 * Current list of datatypes for fixed-function devices (those that always
 * generate the same types of data and thus can declare their data types in
 * code).
 */
#define HOUND_DATA_ACCEL ((hound_data_id) 0x00000000)
#define HOUND_DATA_GYRO ((hound_data_id) 0x00000001)
#define HOUND_DATA_GPS ((hound_data_id) 0x00000002)

/* Data. */

typedef uint_least32_t hound_data_id;
typedef uint_least8_t hound_dev_id;
typedef uint_least64_t hound_seqno;
typedef uint_least32_t hound_record_size;

/** max length for a device name, including the null character. */
#define HOUND_DEVICE_NAME_MAX 32

/** max number of data IDs requested per context. */
#define HOUND_MAX_DATA_REQ 1000

struct hound_record {
    /** an ID uniquely describing a datatype. */
    hound_data_id data_id;

    /** an ID uniquely describing a device. */
    hound_dev_id dev_id;

    /** the timestamp of this record, as given by the underlying driver. */
    struct timespec timestamp;

    /** the size of this record. */
    hound_record_size size;

    /** the data for this record. */
    unsigned char *data;
};

/**
 * A callback used to fetch records from a context's queue.
 *
 * @param[in] rec a record
 * @param[in] seqno The sequence number of this record, used to check if the
 *                  queue has overflow. This increments once per record created
 *                  in the queue.
 * @param[in] cb_ctx callback context, as passed into a hound data request
 */
typedef void (*hound_cb)(
    const struct hound_record *rec,
    hound_seqno seqno,
    void *cb_ctx);

typedef uint_fast8_t hound_period_count;
typedef uint_fast64_t hound_data_period;

/**
 * Allowable units for data generated by drivers. These are SI units as much as
 * possible. Time is an exception, as specifying everything in seconds will
 * result in floating point issues.
 */
typedef enum {
    HOUND_UNIT_DEGREE,
    HOUND_UNIT_KELVIN,
    HOUND_UNIT_KG_PER_S,
    HOUND_UNIT_LATITUDE,
    HOUND_UNIT_LONGITUDE,
    HOUND_UNIT_METER,
    HOUND_UNIT_METERS_PER_S,
    HOUND_UNIT_METERS_PER_S_SQUARED,
    HOUND_UNIT_NONE,
    HOUND_UNIT_PASCAL,
    HOUND_UNIT_PERCENT,
    HOUND_UNIT_RAD,
    HOUND_UNIT_RAD_PER_S,
    HOUND_UNIT_NANOSECOND,
} hound_unit;

/**
 * Allowable types for data generated by drivers. These are mappable to C
 * primitive types.
 */
typedef enum {
    HOUND_TYPE_BOOL,
    HOUND_TYPE_BYTES,
    HOUND_TYPE_DOUBLE,
    HOUND_TYPE_FLOAT,
    HOUND_TYPE_INT16,
    HOUND_TYPE_INT32,
    HOUND_TYPE_INT64,
    HOUND_TYPE_INT8,
    HOUND_TYPE_UINT16,
    HOUND_TYPE_UINT32,
    HOUND_TYPE_UINT64,
    HOUND_TYPE_UINT8
} hound_type;

struct hound_data_fmt {
    /** the name of this data. */
    const char *name;

    /** the unit of this data. */
    hound_unit unit;

    /** the byte offset of this data inside a record. */
    size_t offset;

    /**
     * The length of this data, in bytes. A size of 0 means "all the rest of the
     * data", and such a value must be the last specified data format in a given
     * record so that all fields can be parsed.
     */
    size_t size;

    /** the type of the given data format. */
    hound_type type;
};

struct hound_datadesc {
    /** an ID uniquely describing a datatype. */
    hound_data_id data_id;

    /** an ID uniquely describing a device. */
    hound_dev_id dev_id;

    /** the name of this datatype. */
    const char *name;

    /** the number of available periods for this data */
    hound_period_count period_count;

    /** an array of periods available for this data */
    hound_data_period *avail_periods;

    /** the number of data formats inside a given record */
    size_t fmt_count;

    /** an array of data formats */
    struct hound_data_fmt *fmts;

};

struct hound_data_rq {
    /** a data ID to be requested */
    hound_data_id id;

    /** the period (in nanoseconds) to generate this data */
    hound_data_period period_ns;
};

struct hound_data_rq_list {
    /** the length of the data request list */
    size_t len;

    /** an array, of the given length, containing data requests */
    struct hound_data_rq *data;
};

struct hound_rq {
    /**
     * The number of records in the circular buffer hound uses to queue up data
     * after it's generated and before it's consumed.
     */
    size_t queue_len;

    /**
     * A callback function, which will be called by hound_read and friends for
     * each record to be read from the context's queue.
     */
    hound_cb cb;

    /**
     * Arbitrary user context to be passed into each invocation of the callback
     * function.
     */
    void *cb_ctx;

    /** a data request list */
    struct hound_data_rq_list rq_list;
};

struct hound_init_arg {
    /**
     * The type for this init argument, used to figure out which union element
     * to consult.
     */
    hound_type type;
    union {
        bool as_bool;
        float as_float;
        double as_double;
        int8_t as_int8;
        uint8_t as_uint8;
        int16_t as_int16;
        uint16_t as_uint16;
        int32_t as_int32;
        uint32_t as_uint32;
        int64_t as_int64;
        uint64_t as_uint64;
        const unsigned char *as_bytes;
    } data;
};

/**
 * Gets the descriptors for available sensors on this system.
 *
 * @param[out] descs an array of descriptors
 * @param[out] len the length of the array of descriptors
 *
 * @return an error code
 */
hound_err hound_get_datadescs(struct hound_datadesc **descs, size_t *len);

/**
 * Frees a list of descriptors acquired by a call to hound_free_datadesc.
 *
 * @param[in] descs an array of descriptors
 */
void hound_free_datadescs(struct hound_datadesc *descs);

/* Devices. */

/** Opaque pointer to an I/O context. */
struct hound_ctx;

/**
 * Gets the name of a given device.
 *
 * @param[in] id a device ID
 * @param[out] filled in with a device name, if not NULL. Must not be modified
 *             or freed by the user. Setting name to NULL can be used to check
 *             for the existence of a driver with the given device ID.
 *
 * @return an error code
 */
hound_err hound_get_dev_name(hound_dev_id id, const char **name);

/**
 * Allocates a context containing the given request. This context will be used
 * to start and stop data generation.
 *
 * @param[in] rq a request containing the data to generate
 * @param[out] ctx filled in with an opaque context pointer
 *
 * @return an error code
 */
hound_err hound_alloc_ctx(const struct hound_rq *rq, struct hound_ctx **ctx);

/**
 * Modifies an existing context to produce a different set of data.
 *
 * @param[in] ctx an already-allocated context
 * @param[in] rq a request containing the data the context should now generate
 * @param[in] flush if true, empty the queue of any pending records. if false,
 *                  the callback specified in the new request must be able to
 *                  handle data that was part of the previous request in the
 *                  context.
 *
 * @return an error code. If HOUND_OK is returned, the request was successful.
 */
hound_err hound_modify_ctx(
    struct hound_ctx *ctx,
    const struct hound_rq *rq,
    bool flush);

/**
 * Frees a context.
 *
 * @param[in] ctx a context to be freed
 */
hound_err hound_free_ctx(struct hound_ctx *ctx);

/**
 * Starts the context generating and queueing data.
 *
 * @param[in] ctx a context
 *
 * @return an error code
 */
hound_err hound_start(struct hound_ctx *ctx);

/**
 * Stops the generation and queueing of data.
 *
 * @param[in] ctx a context
 *
 * @return an error code
 */
hound_err hound_stop(struct hound_ctx *ctx);

/**
 * Asks all drivers underlying this context to produce data. This call is useful
 * only for on-demand (period == 0) data, and it does nothing for periodic
 * drivers.
 *
 * @param[in] ctx a context
 * @param[in] n the number of records to produce.
 *
 * @return an error code
 */
hound_err hound_next(struct hound_ctx *ctx, size_t n);

/**
 * Triggers callback invocations to process queued data, blocking until all
 * requested data has finished a callback invocation.  Also calls hound_next()
 * for any pull-mode data.
 *
 * @param[in]  ctx a context
 * @param[in]  records the number of records to read. Reads the records as fast
 *             as possible, blocking when the queue is empty until a new item is
 *             available.
 * @param[out] read if not NULL, filled in with the number of records that were
 *                  read This will generally be the requested number of records,
 *                  but it can be less if HOUND_CTX_STOPPED is returned.
 *
 * @return HOUND_OK, or HOUND_CTX_STOPPED if the context is stopped during the
 *         read. If HOUND_CTX_STOPPED is returned, then the number of records
 *         read may be less than the number requested.
 */
hound_err hound_read(struct hound_ctx *ctx, size_t records, size_t *read);

/**
 * Triggers callback invocations to process queued data. If fewer than n records
 * are available, processes callbacks on what is available instead of blocking
 * until n records are available. Callbacks for any available data are still
 * guaranteed to have completed upon return. This function does not call
 * hound_next(), so it is useless for pull-mode data.
 *
 * @param[in] ctx a context
 * @param[in] records trigger callbacks for up to the specified records. If fewer
 *                    than this count is available, reads all available records.
 * @param[out] read filled in to indicate how many records were actually read.
 *
 * @return an error code
 */
hound_err hound_read_nowait(struct hound_ctx *ctx, size_t records, size_t *read);

/**
 * Triggers callback invocations to process queued data. If fewer than n records
 * are available, processes callbacks on what is available instead of blocking
 * until n records are available. Callbacks for any available data are still
 * guaranteed to have completed upon return. This function does not call
 * hound_next(), so it is useless for pull-mode data.
 *
 * This form of read_nowait will trigger callbacks on up to the specified number
 * of bytes of records. The callback will take the same form as usual,
 * triggering on a per-record basis. However, the sum of the record sizes
 * triggered will not exceed the specified number of bytes.
 *
 * @param[in] ctx a context
 * @param[in] bytes trigger callbacks for up to the specified bytes of records. If
 *                  fewer than this count is available, reads all available
 *                  records.
 * @param[out] records_read filled in to indicate how many records were actually read
 * @param[out] bytes_read filled in to indicate how many bytes were actually read
 *
 * @return an error code
 */
hound_err hound_read_bytes_nowait(
    struct hound_ctx *ctx,
    size_t bytes,
    size_t *records_read,
    size_t *bytes_read);

/**
 * Triggers callback invocations to process all currently available data. This
 * is equivalent to calling hound_read_nowait(ctx, INFINITY).
 *
 * @param[in] ctx a context
 * @param[out] read filled in to indicate how many records were actually read
 *
 * @return an error code
 */
hound_err hound_read_all_nowait(struct hound_ctx *ctx, size_t *read);

/**
 * Returns how many records are currently available in the queue.
 *
 * @param[in] ctx a context
 * @param[out] count filled in with the current number of available records
 *
 * @return an error code
 */
hound_err hound_queue_length(struct hound_ctx *ctx, size_t *count);

/**
 * Returns the maximum queue length.
 *
 * @param[in] ctx a context
 * @param[out] count filled in with the max number of records
 *
 * @return an error code
 */
hound_err hound_max_queue_length(struct hound_ctx *ctx, size_t *count);

/**
 * Initializes drivers specified in the given config file.
 *
 * @param[in] config the path to a driver config file
 *
 * @return an error code
 */
hound_err hound_init_config(const char *config, const char *schema_base);

/**
 * Initializes a driver with a concrete device.
 *
 * @param[in] name the name of the driver
 * @param[in] path the path to a device file
 * @param[in] schema_base the directory in which schema files reside, or NULL,
 *                        which will use the default schema directory
 * @param[in] schema the name of a schema to use
 * @param[in] arg_count the number of driver init argumnts
 * @param[in] args an array of strings representing driver init arguments
 *
 * @return an error code
 */
hound_err hound_init_driver(
    const char *name,
    const char *path,
    const char *schema_base,
    const char *schema,
    size_t arg_count,
    const struct hound_init_arg *args);

/**
 * Destroys a registered driver at the given path, effectively unloading the
 * backing driver.
 *
 * @param[in] path the path to a device file
 *
 * @return an error code
 */
hound_err hound_destroy_driver(const char *path);

/**
 * Destroys all registered drivers.
 * backing driver.
 *
 * @param[in] path the path to a device file
 *
 * @return an error code
 */
hound_err hound_destroy_all_drivers(void);

#ifdef __cplusplus
}
#endif

#endif /* HOUND_H_ */
